
grep   （文本过滤工具，模式是pattern）匹配的是行的内容    

正则表达式中采用的是贪婪模式：尽可能长的匹配

man  7  regex  查看帮助


-i  忽略大小写
-n 把匹配的内容显示出行号
-c 统计匹配的行数
-o 仅显示匹配到的字符串             grep  -o  雷  |  wc -l  计算出现“雷”这个字的次数
-q 静默模式，不输出任何信息，不论找不找得到都不显示，类似于 " &> /dev/null "  把文件
丢进垃圾箱    怎么判断是否找到了呢?      echo $?        如果找到了就显示为   0     如果没找
到就显示为1


-v     取反
-A “数字”       after，后   "数字"  行
-B  “数字”      before，前“数字”行 
-C  “数字”      context，前后各“数字”行
-e     或者  

那怎么表示“并且”的关系呢？  
用管道匹配两次


-w 匹配整个单词

-E  使用ERE

-F   相当于使用fgrep，不支持正则表达式，就是用普通字符串过滤

-f file  根据模式文件处理，换种方式就是说，读取“file”文件里面的内容，以里面的内容为
要过滤的标准来匹配我们后面的参数。

下面这个是例子：

思路是先在一个叫“test.txt”的文件中写入“root”这个单词，再用这个单词
为过滤的标准，去找/etc/passwd中有这个单词的匹配条目

[root centos7]#cat > test.txt
root
^C
[root centos7]#cat test.txt
root
[root centos7]#grep  -f   test.txt  /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin




正则表达式：

^$  
^开头，$结尾 ,中间啥也没有，这就表示空行

^[[:space:]]*$
^开头，$结尾 ,中间用任意个数的空白符表示，代表空白行


字符匹配: 
.   匹配任意单个字符 
[]  匹配指定范围内的任意单个字符，示例：[wang]   [0-9]    [a-z]   [a-zA-Z] 
[^] 匹配指定范围外的任意单个字符 
[:alnum:] 字母和数字 
[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z 
[:lower:] 小写字母 [:upper:] 大写字母 
[:blank:] 空白字符（空格和制表符） 
[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广） 
[:cntrl:] 不可打印的控制字符（退格、删除、警铃...） 
[:digit:] 十进制数字 
[:xdigit:]十六进制数字 
[:graph:] 可打印的非空白字符 
[:print:] 可打印字符 
[:punct:] 标点符号


匹配次数：用在要指定次数的字符后面，用于指定前面的字符要出现的次数 
* 匹配前面的字符任意次，包括0次 
             贪婪模式：尽可能长的匹配 
.* 任意长度的任意字符 
\? 匹配其前面的字符0或1次 
\+ 匹配其前面的字符至少1次 
\{n\} 匹配前面的字符n次 
\{m,n\} 匹配前面的字符至少m次，至多n次 
\{,n\} 匹配前面的字符至多n次 
\{n,\} 匹配前面的字符至少n次



位置锚定：定位出现的位置 
^ 行首锚定，用于模式的最左侧 
$ 行尾锚定，用于模式的最右侧 
^PATTERN$  用于模式匹配整行 
^$  空行 
^[[:space:]]*$  空白行 
\< 或 \b 词首锚定，用于单词模式的左侧 
\> 或 \b 词尾锚定，用于单词模式的右侧 
\<PATTERN\> 匹配整个单词



减号和空格 可以作为单词的分割符，数字、字母、下划线都算单词的内容
除了数字、字母、下划线之外其他符号都可以作为单词的分割符号



分组：\(\) 将一个或多个字符捆绑在一起，当作一个整体处理，
如：\(root\)\+ 

分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，
这些 变量的命名方式为: \1, \2, \3, ... 

\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到
的字符 
示例： 
\(string1\+\(string2\)*\) 
\1 ：string1\+\(string2\)* 
\2 ：string2 


后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身 ，一开
始出现了你需要的字符串，后来在同一行的后面又见到了同一段字符串

或者：\| 
示例：
a\|b: a或b  
C\|cat: C或cat   
\(C\|c\)at:Cat或cat


取出ifconfig中的所有IP地址

ifconfig | grep -o "\<\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}\>"

实际上这个语法还是不够严谨范围要是    666.666.666.666    也会被识别出来，只是在虚拟机中使用ifconfig的时候默认显示的都是“规范”的IP地址所以
都能够过滤出来!
实际上下面这个IP地址相对而言要更规范一些
ifconfig|egrep -o "\< (( 1?[0-9]?[0-9] | 2[0-4][0-9] | 25[0-5] )\.) {3} ( 1?[0-9]?[0-9] | 2[0-4][0-9] | 25[0-5] ) \>"
主要有下面这几部分组成：
[1-9]?[0-9]|1[0-9][0-9] 或  1?[0-9]?[0-9]
2[0-4][0-9]
25[0-5]
\.
{3}

